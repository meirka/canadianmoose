name: Notify Telegram on new Topic

on:
  discussion_comment:
    types: [created]
  workflow_dispatch: {}   # optional: lets you test manually

permissions:
  discussions: read
  contents: read

jobs:
  send:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - uses: actions/github-script@v7
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TG_CHAT:  ${{ secrets.TELEGRAM_CHAT_ID }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // github, context, core, fetch are provided by github-script (Node 20).

            if (context.eventName === 'workflow_dispatch') {
              core.info('Manual run - nothing to do.'); return;
            }
            if (context.payload.action !== 'created') {
              core.info('Not a create action; skipping.'); return;
            }

            const discussionNumber = context.payload.discussion?.number;
            const commentUrl = context.payload.comment?.html_url;
            const commentNodeId = context.payload.comment?.node_id;

            if (!discussionNumber || !commentUrl || !commentNodeId) {
              core.info('Missing discussion/comment info (need number, html_url, node_id); skipping.');
              return;
            }

            // GraphQL: get discussion category + the comment (via node(id:))
            const q = [
              'query($owner:String!, $repo:String!, $number:Int!, $commentId:ID!) {',
              '  repository(owner:$owner, name:$repo) {',
              '    discussion(number:$number) {',
              '      title',
              '      url',
              '      category { name id }',
              '    }',
              '  }',
              '  node(id:$commentId) {',
              '    __typename',
              '    ... on DiscussionComment {',
              '      id',
              '      body',
              '      createdAt',
              '      author { login url }',
              '      replyTo { id }',
              '    }',
              '  }',
              '}'
            ].join('\n');

            const vars = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              number: discussionNumber,
              commentId: commentNodeId
            };

            const data = await github.graphql(q, vars);
            const disc = data?.repository?.discussion;
            const c = data?.node;

            if (!disc || c?.__typename !== 'DiscussionComment') {
              core.info('Not a discussion comment; skipping.'); return;
            }

            // Only top-level comments in the "Topics" category
            const isTopics = (disc.category?.name || '').toLowerCase() === 'topics';
            const isTopLevel = !(c.replyTo && c.replyTo.id);
            if (!isTopics || !isTopLevel) {
              core.info('Not a top-level comment in Topics; skipping.'); return;
            }

            // Minimal GitHub-Markdown ‚Üí Telegram-HTML converter
            // Allowed Telegram tags: b,strong,i,em,u,ins,s,del,strike,a,code,pre,blockquote,br
            function escText(t) {
              return String(t).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            }
            function escAttr(t) {
              return String(t).replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            }
            function mdToTgHtml(md) {
              if (!md) return '';
              let s = String(md).replace(/\r\n?/g, '\n');
            
              // Fenced code blocks ```lang\n...\n```
              s = s.replace(/```([\s\S]*?)```/g, (_, block) => {
              const withoutLang = block.replace(/^[a-zA-Z0-9_-]+\n/, '');
              return `<pre><code>${escText(withoutLang)}</code></pre>`;
              });
            
              // Headings -> <b>‚Ä¶</b>
              s = s.replace(/^#{1,6}\s*(.+)$/gm, (_, t) => `<b>${escText(t.trim())}</b>\n`);
            
              // Blockquotes
              s = s.replace(/^>\s?(.*)$/gm, (_, t) => `<blockquote>${escText(t)}</blockquote>`);
            
              // Images ![alt](url) -> "alt (url)"
              s = s.replace(/!\[([^\]]*)\]\((https?:\/\/[^)\s]+)\)/g, (_, alt, url) =>
              `${escText(alt || 'image')} (${escText(url)})`
              );
            
              // Links [text](url)
              s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^)\s]+)\)/g, (_, txt, url) =>
              `<a href="${escAttr(url)}">${escText(txt)}</a>`
              );
            
              // Inline code
              s = s.replace(/`([^`\n]+)`/g, (_, code) => `<code>${escText(code)}</code>`);
            
              // Bold / Italic
              s = s.replace(/(\*\*|__)(.*?)\1/g, (_, __, t) => `<b>${escText(t)}</b>`);
              s = s.replace(/(^|[^\*])\*(?!\*)([^*\n]+)\*(?!\*)/g, (_, pre, t) => `${pre}<i>${escText(t)}</i>`);
              s = s.replace(/(^|[^_])_([^_\n]+)_/g,        (_, pre, t) => `${pre}<i>${escText(t)}</i>`);
            
              // Lists -> bullets
              s = s.replace(/^(\s*)[-*+]\s+(.+)$/gm, (_, sp, t) => `${sp}‚Ä¢ ${escText(t)}`);
            
              // Horizontal rule -> break
              s = s.replace(/^\s*---+\s*$/gm, '<br>');
            
              // Collapse big gaps
              s = s.replace(/\n{3,}/g, '\n\n');
            
              // Strip non-allowed tags
              s = s.replace(/<(?!\/?(?:b|strong|i|em|u|ins|s|del|strike|a|code|pre|blockquote|br)\b)[^>]*>/gi, '');
            
              return s.trim();
            }
              
            // Build message parts
            const body = c.body || '';
            const lines = body.split('\n').map(s => s.trim()).filter(Boolean);
            const firstLine = lines[0] || '(–±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è)';
            const rest = lines.slice(1).join(' ');
            const excerpt = rest.length > 240 ? rest.slice(0, 237) + '‚Ä¶' : rest;
              
            // Convert to Telegram-HTML
            const firstHTML = mdToTgHtml(firstLine);
            const excerptHTML = mdToTgHtml(excerpt);
            
            // Compose (put the link you want previewed LAST)
            const parts = [
            'üÜï –ù–æ–≤–æ–µ –æ–±—Å—É–¥–∏—Ç—å: ' + firstHTML,
            excerptHTML ? ('üß© ' + excerptHTML) : null,
            '\nüìã <a href="https://rcmp.cloud/topics/">–≤—Å–µ —Ç–µ–º—ã</a>'
            ].filter(Boolean);
              
            const text = parts.join('\n');
              
            // Send with HTML parse mode (previews ON)
            const resp = await fetch('https://api.telegram.org/bot' + process.env.TG_TOKEN + '/sendMessage', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chat_id: process.env.TG_CHAT,
              text: text.slice(0, 4096),   // Telegram limit
              parse_mode: 'HTML',
              disable_web_page_preview: false
              })
            });
              
            if (!resp.ok) {
              const errTxt = await resp.text();
              core.setFailed('Telegram send failed: ' + resp.status + ' ' + errTxt);
              return;
            }
            core.info('Sent to Telegram ‚úÖ');